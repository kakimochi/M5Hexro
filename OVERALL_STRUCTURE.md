# M5Hexro Project Overall Structure

This document outlines the overall structure of the M5Hexro project, a hexapod robot controlled by an M5Stack microcontroller.

## High-Level Project Structure

The project is organized into two main directories at the root level:

*   **`M5Hexro/`**: This directory contains the firmware for the M5Stack microcontroller that directly controls the hexapod robot. It includes the main application logic, hardware interface code, and platform configuration.
*   **`material/`**: This directory contains supplementary materials, most notably a Jupyter notebook used for generating the robot's gait patterns.

## `M5Hexro/` Directory Details

This directory houses the firmware for the M5Stack controller.

*   **`src/main.cpp`**: This is the heart of the robot's firmware. Its responsibilities include:
    *   **Robot Control Logic**: Implementing various motion patterns (e.g., walking, idle, stretching).
    *   **Hardware Initialization and Interaction**: Setting up and managing communication with I2C devices like the PA HUB and 8-Servo units.
    *   **Servo Management**: Sending angle commands to the servos based on the selected motion pattern.
    *   **User Interface (GUI)**: Displaying information (current motion, battery level, button functions) on the M5Stack's screen.
    *   **Input Handling**: Processing button presses to change motion patterns or pause/resume operation.

*   **`src/M5_UNIT_8SERVO.h` and `src/M5_UNIT_8SERVO.cpp`**: These files define the `M5_UNIT_8SERVO` class, which provides an abstraction layer for communicating with the M5Stack 8-Servo driver units. This class simplifies servo control by handling the underlying I2C communication and register manipulation required to set servo angles, modes, etc.

*   **`platformio.ini`**: This is the configuration file for the PlatformIO IDE. It specifies the board being used (e.g., M5Stack Core2), framework (Arduino), dependent libraries, and other build settings.

*   **`include/`**: This directory is typically used for project-specific header files. In this project, it currently contains a `README` placeholder. External library headers are usually managed by PlatformIO itself.

*   **`lib/`**: This directory is intended for project-specific libraries or libraries not managed by the PlatformIO library manager. It currently contains a `README` placeholder.

## `material/` Directory Details

This directory contains supplementary materials related to the project.

*   **`M5Hexro_gait_simulation.ipynb`**: This is a Jupyter Notebook file that plays a crucial role in generating the hexapod's walking gait.
    *   **Purpose**: It implements the kinematic calculations for a tripod gait, which is a common walking pattern for six-legged robots where two sets of three legs alternate in providing support and propulsion.
    *   **Kinematics**: The notebook defines the robot's physical dimensions (leg segment lengths) and uses inverse kinematics to calculate the required servo angles (`theta1` for hip horizontal, `theta2` for hip/leg vertical) for each of the six legs to achieve the desired foot placements during the gait cycle. While the simulation in the notebook also calculates a `theta3` (knee joint), the firmware in `main.cpp` uses a 2-degrees-of-freedom (2DOF) model per leg (Leg and Foot joints).
    *   **Output**: The primary output of this notebook is a C++ array named `pattern_walk`. This array contains sequences of servo angle values (in degrees) for each of the 12 servos (6 legs x 2 servos/leg).
    *   **Workflow**: The `pattern_walk` array generated by the notebook is manually copied into `M5Hexro/src/main.cpp`. This array is then used by the firmware to command the servos and produce the walking motion. The notebook essentially serves as an offline tool for gait generation.

## Hardware Components and Interaction

The M5Hexro robot utilizes several key hardware components:

*   **M5Stack Core Module**: This is the central microcontroller brain of the robot (e.g., M5Stack Core2). It runs the firmware located in the `M5Hexro/` directory. It's responsible for all processing, decision-making, and I/O operations, including driving the display and reading button inputs.

*   **PA HUB (I2C Multiplexer)**: The M5Stack module has a limited number of I2C ports. To communicate with multiple I2C devices that might have the same address (or just to organize connections), a PA HUB (like the SparkFun Qwiic Mux) is used.
    *   In this project, the PA HUB allows the M5Stack Core to select and communicate with one of two 8-Servo Units at a time, even if they share the same I2C address. The `main.cpp` code explicitly sets the active channel on the PA HUB before communicating with a specific 8-Servo Unit.

*   **M5Stack 8-Servo Units**: These are I2C-based servo driver boards. Each unit can control up to 8 individual servo motors.
    *   The hexapod has 12 servos in total. Therefore, two 8-Servo Units are used.
    *   `ID_8SERVO_UNIT_0` is connected to one port of the PA HUB and controls the first set of servos.
    *   `ID_8SERVO_UNIT_1` is connected to another port of the PA HUB and controls the remaining servos.
    *   The `M5_UNIT_8SERVO` class in the firmware handles the I2C commands to these units to set servo angles.

*   **Servomotors**: 12 servomotors are used to actuate the robot's legs.

*   **Leg Structure**: The hexapod has six legs. Each leg is controlled by two servomotors:
    *   **Leg Servo**: Corresponds to `theta1` in the simulation, controlling the hip's horizontal rotation (forward/backward swing of the leg relative to the body).
    *   **Foot Servo**: Corresponds to `theta2` in the simulation, controlling the hip/femur's vertical rotation (lifting/lowering the leg).
    *   This 2-DOF (Degrees of Freedom) per leg configuration allows for basic walking and posing. The `ServoAssign` enum in `main.cpp` maps these 12 servos to specific leg joints (e.g., `FL_Leg`, `FR_Foot`).

## Control Flow

The firmware's control flow is managed through the standard Arduino `setup()` and `loop()` functions.

*   **Boot Sequence (`setup()` function):**
    1.  **M5Stack Initialization**: The M5Stack Core module and its peripherals (Power, Display) are initialized using `M5.begin()` and `M5.Power.begin()`.
    2.  **I2C Initialization**: The I2C bus (`Wire.begin()`) is configured with the specified SDA and SCL pins.
    3.  **PA HUB Detection**: The code attempts to communicate with the PA HUB I2C multiplexer. If not detected, it halts with an error.
    4.  **8-Servo Unit Initialization**:
        *   The code iterates through the PA HUB channels designated for the servo units.
        *   For each channel, it selects the port on the PA HUB (`i2cMux.setPort()`).
        *   It then attempts to initialize the connected 8-Servo Unit (`unit_8servo[ch_pahub].begin()`). If a unit fails to connect, the system halts.
        *   All pins on each detected 8-Servo Unit are set to `SERVO_CTL_MODE`.
    5.  **GUI Setup**: The initial user interface is drawn on the M5Stack's display, showing the application name, version, initial battery level, and button instructions. The initial motion pattern is also displayed.
    6.  **Motion Timer Initialization**: A hardware timer (`timerMotion`) is configured to trigger an interrupt (`onTimerMotion`) periodically (every 50ms as defined by `TIMER_MOTION_INTERVAL_US`). This interrupt is responsible for setting a `motion_trigger` flag.
    7.  **Initial Beep**: A sequence of tones is played to indicate that initialization is complete.

*   **Main Loop (`loop()` function):**
    1.  **M5Stack Update**: `M5.update()` is called to refresh button states and other M5Stack internal processes.
    2.  **Button Event Handling**:
        *   **BtnA (Pause/Resume)**: If BtnA is pressed, the motion timer (`timerAlarmDisable(timerMotion)`) is disabled, effectively pausing the robot's movements. The robot then waits in a loop until BtnC is pressed.
        *   **BtnC (Resume/Play in Pause Context)**: If BtnC is pressed (either during normal operation or while paused by BtnA), the motion timer (`timerAlarmEnable(timerMotion)`) is enabled (or re-enabled), allowing robot movements to start or resume.
        *   **BtnB (Select Motion Pattern)**: If BtnB is pressed, the `motionPattern` variable is incremented, cycling through the available motion patterns (Idle, Walk, Stretch, etc.). The GUI is updated to reflect the newly selected pattern.
    3.  **Motion Execution**:
        *   The `loop()` checks the `motion_trigger` flag. This flag is set to `true` by the `onTimerMotion` interrupt service routine (ISR) which is called every 50ms.
        *   If `motion_trigger` is true, the code executes the function corresponding to the currently selected `motionPattern` (e.g., `MotionWalk()`, `MotionIdle()`). These functions call `setServoAngle()` to command the servos to their new positions for the current step of the motion.
        *   After executing the motion function, `motion_trigger` is reset to `false`.
    4.  **Periodic Tasks**:
        *   The battery level is checked and updated on the display every 10 seconds (`interval_10sec`).
    5.  **Delay**: A small delay (`vTaskDelay(50)`) is introduced to yield processing time, allowing other tasks (like the FreeRTOS system tasks on ESP32) to run.

*   **Motion Patterns**:
    *   The robot has several predefined motion patterns defined by the `MotionPattern` enum (e.g., `MP_MotionOrigin`, `MP_MotionIdle`, `MP_MotionWalk`, `MP_MotionStretching`, `MP_MotionTapping`).
    *   Each pattern has a corresponding function (e.g., `MotionOrigin()`, `MotionWalk()`) that contains the logic to set servo angles for that specific motion.
    *   The `MotionWalk()` pattern, for instance, iterates through the `pattern_walk` array (generated by the Jupyter notebook) to set the angles for all 12 servos for each step of the gait.
    *   Other motions like `MotionIdle` or `MotionStretching` implement simpler, predefined servo movements.

## Building and Deploying the Code

The firmware in the `M5Hexro/` directory is managed as a PlatformIO project.

*   **PlatformIO**: PlatformIO is an open-source ecosystem for embedded development. It provides a command-line interface (CLI) and an IDE extension (commonly used with Visual Studio Code) that simplifies project building, library management, and uploading firmware to microcontrollers.

*   **To build and deploy the code**:
    1.  Ensure you have PlatformIO installed (either the Core CLI or the VSCode extension).
    2.  Open the `M5Hexro/` directory in your PlatformIO-enabled environment (e.g., open the folder in VSCode with the PlatformIO extension installed).
    3.  PlatformIO will automatically detect the `platformio.ini` file and configure the project.
    4.  Use the PlatformIO commands/buttons to:
        *   **Build**: Compile the source code.
        *   **Upload**: Flash the compiled firmware to the connected M5Stack device.
        *   **Monitor**: Open a serial monitor to view debug messages (`Serial.printf`) from the device.

## Generating Custom Gait Patterns

The primary walking gait (`pattern_walk`) used in `main.cpp` is generated using the Jupyter Notebook found at `material/M5Hexro_gait_simulation.ipynb`. If you wish to modify the existing gait or create a new one, follow these steps:

1.  **Open the Jupyter Notebook**: Navigate to the `material/` directory and open `M5Hexro_gait_simulation.ipynb` in a Jupyter Notebook environment (e.g., Jupyter Lab, VSCode with Python extension).

2.  **Modify Parameters (Optional)**:
    *   Inside the notebook, primarily within the `mainApp` class's `calc()` method, you can adjust parameters that influence the gait, such as:
        *   `num_divide`: The number of steps or frames in one complete gait cycle.
        *   `stroke_step_length_a`: The length of each step (stride).
        *   `stroke_step_length_b`: The height of each step.
        *   `distance_a`: Default horizontal distance of the foot from the body.
        *   `distance_b`: Default vertical distance of the foot from the body (ground clearance).
        *   The kinematic model itself or the phase differences for a different type of gait (e.g., wave gait instead of tripod).
    *   You can also adjust the `frames` variable in the `if __name__ == '__main__':` block to change the total number of steps generated for the C++ array. The current `pattern_walk` in `main.cpp` seems to use 50 frames (0-49).

3.  **Run the Notebook**: Execute all cells in the notebook. This will perform the kinematic calculations and generate the gait data.

4.  **Copy the C++ Array**:
    *   The notebook's output will include a section that prints a C++ array definition for `pattern_walk[][]`. It will look similar to this:
        ```cpp
        float pattern_walk[][1+NUM_LEG_STRUCTURE*NUM_LEGS] = {
            { 0 ,90.0,61.812,66.206,75.879,90.0,61.812,116.565,60.301,90.0,61.812,80.104,63.008 },
            // ... more lines
        };
        ```
    *   Carefully copy this entire array definition.

5.  **Replace in `main.cpp`**:
    *   Open `M5Hexro/src/main.cpp`.
    *   Locate the existing `pattern_walk` array.
    *   Delete the old array values (the lines between `{` and `};`).
    *   Paste the new array data that you copied from the notebook. Ensure the variable name and type match.

6.  **Rebuild and Deploy**:
    *   Using PlatformIO, rebuild the firmware.
    *   Upload the updated firmware to your M5Hexro robot.
    *   Test the new gait pattern.

**Note**: The simulation in the notebook calculates three angles per leg (theta1, theta2, theta3), but the `generate_cpp_struct` function in the notebook and the `pattern_walk` array in `main.cpp` only use two angles per leg (corresponding to `Leg` and `Foot` servos, effectively `theta1` and `theta2` after coordinate adjustments). Ensure your understanding of the mapping if you significantly alter the kinematics.
