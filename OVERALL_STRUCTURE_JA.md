# M5Hexroプロジェクト全体構成

本文書は、M5Stackマイクロコントローラによって制御されるヘキサポッドロボット、M5Hexroプロジェクトの全体構成を概説します。

## 高レベルプロジェクト構成

プロジェクトは、ルートレベルで主に2つのディレクトリに構成されています。

*   **`M5Hexro/`**: このディレクトリには、ヘキサポッドロボットを直接制御するM5Stackマイクロコントローラ用のファームウェアが含まれています。これには、メインアプリケーションロジック、ハードウェアインターフェースコード、およびプラットフォーム構成が含まれます。
*   **`material/`**: このディレクトリには、特にロボットの歩行パターンを生成するために使用されるJupyterノートブックなど、補足資料が含まれています。

## `M5Hexro/` ディレクトリ詳細

このディレクトリには、M5Stackコントローラ用のファームウェアが格納されています。

*   **`src/main.cpp`**: これはロボットのファームウェアの中心部分です。主な責務は以下の通りです。
    *   **ロボット制御ロジック**: 様々な動作パターン（歩行、待機、ストレッチなど）の実装。
    *   **ハードウェア初期化と対話**: PA HUBや8サーボユニットなどのI2Cデバイスとの通信のセットアップと管理。
    *   **サーボ管理**: 選択された動作パターンに基づいてサーボに角度コマンドを送信。
    *   **ユーザーインターフェース (GUI)**: M5Stackの画面に情報（現在の動作、バッテリーレベル、ボタン機能）を表示。
    *   **入力処理**: ボタン押下を処理して動作パターンを変更したり、操作を一時停止/再開したりします。

*   **`src/M5_UNIT_8SERVO.h` および `src/M5_UNIT_8SERVO.cpp`**: これらのファイルは`M5_UNIT_8SERVO`クラスを定義します。このクラスは、M5Stack 8サーボドライバユニットとの通信のための抽象化レイヤーを提供します。サーボ角度やモードなどを設定するために必要な基盤となるI2C通信とレジスタ操作を処理することにより、サーボ制御を簡素化します。

*   **`platformio.ini`**: これはPlatformIO IDEの設定ファイルです。使用するボード（例: M5Stack Core2）、フレームワーク（Arduino）、依存ライブラリ、およびその他のビルド設定を指定します。

*   **`include/`**: このディレクトリは通常、プロジェクト固有のヘッダーファイルに使用されます。このプロジェクトでは、現在`README`プレースホルダーが含まれています。外部ライブラリのヘッダーは通常、PlatformIO自体によって管理されます。

*   **`lib/`**: このディレクトリは、プロジェクト固有のライブラリ、またはPlatformIOライブラリマネージャによって管理されていないライブラリを対象としています。現在`README`プレースホルダーが含まれています。

## `material/` ディレクトリ詳細

このディレクトリには、プロジェクトに関連する補足資料が含まれています。

*   **`M5Hexro_gait_simulation.ipynb`**: これは、ヘキサポッドの歩行パターン生成において重要な役割を果たすJupyter Notebookファイルです。
    *   **目的**: 3本足で支持と推進を交互に行う、6足ロボットの一般的な歩行パターンであるトライポッド歩容の運動学的計算を実装しています。
    *   **運動学**: ノートブックはロボットの物理的寸法（脚のセグメント長）を定義し、逆運動学を使用して、歩行サイクル中に目的の足の配置を実現するために必要な6本の各脚のサーボ角度（`theta1`：腰の水平方向、`theta2`：腰/脚の垂直方向）を計算します。ノートブック内のシミュレーションでは`theta3`（膝関節）も計算しますが、`main.cpp`のファームウェアは脚ごとに2自由度（2DOF）モデル（LegおよびFoot関節）を使用します。
    *   **出力**: このノートブックの主な出力は、`pattern_walk`という名前のC++配列です。この配列には、12個のサーボ（6脚×2サーボ/脚）それぞれのサーボ角度値（度単位）のシーケンスが含まれています。
    *   **ワークフロー**: ノートブックによって生成された`pattern_walk`配列は、手動で`M5Hexro/src/main.cpp`にコピーされます。この配列は、ファームウェアがサーボを制御し、歩行動作を生成するために使用されます。ノートブックは、本質的に歩行生成のためのオフラインツールとして機能します。

## ハードウェアコンポーネントと相互作用

M5Hexroロボットは、いくつかの主要なハードウェアコンポーネントを利用しています。

*   **M5Stackコアモジュール**: これはロボットの中央マイクロコントローラ頭脳です（例：M5Stack Core2）。`M5Hexro/`ディレクトリにあるファームウェアを実行します。ディスプレイの駆動やボタン入力の読み取りを含む、すべての処理、意思決定、およびI/O操作を担当します。

*   **PA HUB (I2Cマルチプレクサ)**: M5Stackモジュールには限られた数のI2Cポートしかありません。同じアドレスを持つ可能性のある複数のI2Cデバイスと通信するため（または単に接続を整理するため）、PA HUB（SparkFun Qwiic Muxなど）が使用されます。
    *   このプロジェクトでは、PA HUBにより、M5Stack Coreは、たとえ同じI2Cアドレスを共有していても、一度に2つの8サーボユニットのいずれかを選択して通信できます。`main.cpp`コードは、特定の8サーボユニットと通信する前に、PA HUBのアクティブなチャネルを明示的に設定します。

*   **M5Stack 8サーボユニット**: これらはI2Cベースのサーボドライバボードです。各ユニットは最大8個の個別サーボモーターを制御できます。
    *   ヘキサポッドには合計12個のサーボがあります。したがって、2つの8サーボユニットが使用されます。
    *   `ID_8SERVO_UNIT_0`はPA HUBの一方のポートに接続され、最初のサーボセットを制御します。
    *   `ID_8SERVO_UNIT_1`はPA HUBのもう一方のポートに接続され、残りのサーボを制御します。
    *   ファームウェアの`M5_UNIT_8SERVO`クラスは、これらのユニットへのI2Cコマンドを処理してサーボ角度を設定します。

*   **サーボモーター**: ロボットの脚を動かすために12個のサーボモーターが使用されます。

*   **脚構造**: ヘキサポッドには6本の脚があります。各脚は2つのサーボモーターによって制御されます。
    *   **脚サーボ**: シミュレーションの`theta1`に対応し、腰の水平回転（体に対する脚の前後の振り）を制御します。
    *   **足サーボ**: シミュレーションの`theta2`に対応し、腰/大腿部の垂直回転（脚の上下）を制御します。
    *   この脚あたり2自由度（DOF）の構成により、基本的な歩行とポージングが可能です。`main.cpp`の`ServoAssign`列挙型は、これらの12個のサーボを特定の脚関節（例：`FL_Leg`、`FR_Foot`）にマッピングします。

## 制御フロー

ファームウェアの制御フローは、標準のArduino `setup()` および `loop()` 関数を通じて管理されます。

*   **起動シーケンス (`setup()` 関数):**
    1.  **M5Stack初期化**: M5Stackコアモジュールとその周辺機器（電源、ディスプレイ）が `M5.begin()` および `M5.Power.begin()` を使用して初期化されます。
    2.  **I2C初期化**: I2Cバス (`Wire.begin()`) が指定されたSDAおよびSCLピンで設定されます。
    3.  **PA HUB検出**: コードはPA HUB I2Cマルチプレクサとの通信を試みます。検出されない場合、エラーで停止します。
    4.  **8サーボユニット初期化**:
        *   コードはサーボユニット用に指定されたPA HUBチャネルを反復処理します。
        *   各チャネルについて、PA HUB上のポートを選択します (`i2cMux.setPort()`)。
        *   次に、接続された8サーボユニットの初期化を試みます (`unit_8servo[ch_pahub].begin()`)。ユニットの接続に失敗した場合、システムは停止します。
        *   検出された各8サーボユニットのすべてのピンが `SERVO_CTL_MODE` に設定されます。
    5.  **GUIセットアップ**: 初期ユーザーインターフェースがM5Stackのディスプレイに描画され、アプリケーション名、バージョン、初期バッテリーレベル、およびボタンの指示が表示されます。初期動作パターンも表示されます。
    6.  **動作タイマー初期化**: ハードウェアタイマー (`timerMotion`) が、`TIMER_MOTION_INTERVAL_US` で定義された周期（50ミリ秒ごと）で割り込み (`onTimerMotion`) をトリガーするように設定されます。この割り込みは `motion_trigger` フラグを設定する役割を担います。
    7.  **初期ビープ音**: 初期化が完了したことを示すために一連のトーンが再生されます。

*   **メインループ (`loop()` 関数):**
    1.  **M5Stack更新**: ボタンの状態やその他のM5Stack内部プロセスを更新するために `M5.update()` が呼び出されます。
    2.  **ボタンイベント処理**:
        *   **BtnA (一時停止/再開)**: BtnAが押されると、動作タイマー (`timerAlarmDisable(timerMotion)`) が無効になり、ロボットの動きが効果的に一時停止します。その後、ロボットはBtnCが押されるまでループ内で待機します。
        *   **BtnC (一時停止コンテキストでの再開/再生)**: BtnCが押されると（通常動作中またはBtnAによって一時停止されている間）、動作タイマー (`timerAlarmEnable(timerMotion)`) が有効（または再有効化）され、ロボットの動きが開始または再開されます。
        *   **BtnB (動作パターン選択)**: BtnBが押されると、`motionPattern` 変数が増加し、利用可能な動作パターン（待機、歩行、ストレッチなど）を循環します。GUIが更新され、新しく選択されたパターンが反映されます。
    3.  **動作実行**:
        *   `loop()` は `motion_trigger` フラグを確認します。このフラグは、50ミリ秒ごとに呼び出される `onTimerMotion` 割り込みサービスルーチン（ISR）によって `true` に設定されます。
        *   `motion_trigger` が `true` の場合、コードは現在選択されている `motionPattern` に対応する関数（例: `MotionWalk()`、`MotionIdle()`）を実行します。これらの関数は `setServoAngle()` を呼び出し、現在の動作ステップのためにサーボを新しい位置に指令します。
        *   動作関数の実行後、`motion_trigger` は `false` にリセットされます。
    4.  **周期的タスク**:
        *   バッテリーレベルが10秒ごと (`interval_10sec`) に確認され、ディスプレイに更新されます。
    5.  **遅延**: 他のタスク（ESP32上のFreeRTOSシステムタスクなど）が実行できるように、処理時間を譲るために小さな遅延 (`vTaskDelay(50)`) が導入されます。

*   **動作パターン**:
    *   ロボットには、`MotionPattern` 列挙型で定義されたいくつかの事前定義された動作パターンがあります（例: `MP_MotionOrigin`、`MP_MotionIdle`、`MP_MotionWalk`、`MP_MotionStretching`、`MP_MotionTapping`）。
    *   各パターンには、その特定の動作のサーボ角度を設定するロジックを含む対応する関数があります（例: `MotionOrigin()`、`MotionWalk()`）。
    *   例えば `MotionWalk()` パターンは、`pattern_walk` 配列（Jupyterノートブックで生成）を反復処理して、歩容の各ステップの12個すべてのサーボの角度を設定します。
    *   `MotionIdle` や `MotionStretching` などの他の動作は、より単純な事前定義されたサーボ動作を実装します。

## コードのビルドとデプロイ

`M5Hexro/` ディレクトリ内のファームウェアは、PlatformIOプロジェクトとして管理されています。

*   **PlatformIO**: PlatformIOは、組み込み開発向けのオープンソースエコシステムです。プロジェクトのビルド、ライブラリ管理、マイクロコントローラへのファームウェアのアップロードを簡素化するコマンドラインインターフェース（CLI）およびIDE拡張機能（一般的にVisual Studio Codeで使用される）を提供します。

*   **コードをビルドしてデプロイするには**:
    1.  PlatformIOがインストールされていることを確認します（Core CLIまたはVSCode拡張機能のいずれか）。
    2.  PlatformIO対応環境で `M5Hexro/` ディレクトリを開きます（例：PlatformIO拡張機能がインストールされたVSCodeでフォルダを開く）。
    3.  PlatformIOは `platformio.ini` ファイルを自動的に検出し、プロジェクトを設定します。
    4.  PlatformIOのコマンド/ボタンを使用して以下を実行します:
        *   **ビルド**: ソースコードをコンパイルします。
        *   **アップロード**: コンパイルされたファームウェアを接続されたM5Stackデバイスに書き込みます。
        *   **モニター**: シリアルモニターを開き、デバイスからのデバッグメッセージ（`Serial.printf`）を表示します。

## カスタム歩容パターンの生成

`main.cpp` で使用される主要な歩行パターン (`pattern_walk`) は、`material/M5Hexro_gait_simulation.ipynb` にあるJupyter Notebookを使用して生成されます。既存の歩容を変更したり、新しい歩容を作成したい場合は、以下の手順に従ってください。

1.  **Jupyter Notebookを開く**: `material/` ディレクトリに移動し、Jupyter Notebook環境（例: Jupyter Lab、Python拡張機能付きVSCode）で `M5Hexro_gait_simulation.ipynb` を開きます。

2.  **パラメータの変更 (任意)**:
    *   ノートブック内の、主に `mainApp` クラスの `calc()` メソッド内で、歩容に影響を与えるパラメータを調整できます。例えば：
        *   `num_divide`: 1つの完全な歩容サイクル内のステップ数またはフレーム数。
        *   `stroke_step_length_a`: 各ステップの長さ（ストライド）。
        *   `stroke_step_length_b`: 各ステップの高さ。
        *   `distance_a`: 体からの足のデフォルトの水平距離。
        *   `distance_b`: 体からの足のデフォルトの垂直距離（地面とのクリアランス）。
        *   運動学モデル自体、または異なる種類の歩容（例: トライポッドの代わりにウェーブ歩容）のための位相差。
    *   `if __name__ == '__main__':` ブロック内の `frames` 変数を調整して、C++配列用に生成される総ステップ数を変更することもできます。`main.cpp` 内の現在の `pattern_walk` は50フレーム（0-49）を使用しているようです。

3.  **ノートブックの実行**: ノートブック内のすべてのセルを実行します。これにより、運動学的計算が実行され、歩容データが生成されます。

4.  **C++配列のコピー**:
    *   ノートブックの出力には、`pattern_walk[][]` のC++配列定義を出力するセクションが含まれます。これは次のようになります:
        ```cpp
        float pattern_walk[][1+NUM_LEG_STRUCTURE*NUM_LEGS] = {
            { 0 ,90.0,61.812,66.206,75.879,90.0,61.812,116.565,60.301,90.0,61.812,80.104,63.008 },
            // ... さらに多くの行
        };
        ```
    *   この配列定義全体を慎重にコピーしてください。

5.  **`main.cpp` での置換**:
    *   `M5Hexro/src/main.cpp` を開きます。
    *   既存の `pattern_walk` 配列を見つけます。
    *   古い配列の値（`{` と `};` の間の行）を削除します。
    *   ノートブックからコピーした新しい配列データを貼り付けます。変数名と型が一致することを確認してください。

6.  **再ビルドとデプロイ**:
    *   PlatformIOを使用して、ファームウェアを再ビルドします。
    *   更新されたファームウェアをM5Hexroロボットにアップロードします。
    *   新しい歩容パターンをテストします。

**注意**: ノートブック内のシミュレーションでは、脚ごとに3つの角度（theta1、theta2、theta3）を計算しますが、ノートブック内の `generate_cpp_struct` 関数と `main.cpp` 内の `pattern_walk` 配列は、脚ごとに2つの角度（`Leg` および `Foot` サーボに対応し、座標調整後の実質的な `theta1` と `theta2`）しか使用しません。運動学を大幅に変更する場合は、マッピングを理解していることを確認してください。
